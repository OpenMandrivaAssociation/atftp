Index: tftp.c
===================================================================
--- tftp.c.orig
+++ tftp.c
@@ -354,7 +354,7 @@ char *command_generator(const char *text
 void make_arg(char *string, int *argc, char ***argv)
 {
      static char *tmp = NULL;
-     int argz_len;
+     size_t argz_len;
 
      /* split the string to an argz vector */
      if (argz_create_sep(string, ' ', &tmp, &argz_len) != 0)
@@ -731,7 +731,7 @@ int get_file(int argc, char **argv)
      fsync(data.sockfd);
      close(data.sockfd);
 
-     return OK;
+     return tftp_result;
 }
 
 #ifdef HAVE_MTFTP
Index: tftp_file.c
===================================================================
--- tftp_file.c.orig
+++ tftp_file.c
@@ -59,9 +59,9 @@ int tftp_find_bitmap_hole(int prev_hole,
      unsigned int next_word;
 
      /* initial stuff */
-     next_hole = prev_hole + 1;
-     next_word_no = next_hole / 32;
-     next_bit_no  = next_hole % 32;
+     next_hole = 0;
+     next_word_no = next_hole / 32; /* effectively 0 */
+     next_bit_no  = next_hole % 32; /* effectively 0 */
      next_word = bitmap[next_word_no];
     
      /* Check if there is a remainder of the current word to traverse */
@@ -136,7 +136,7 @@ int tftp_receive_file(struct client_data
      struct hostent *host;
      int master_client = 0;
      unsigned int file_bitmap[NB_BLOCK];
-     int prev_bitmap_hole = -1; /* the previous hole found in the bitmap */
+     int prev_bitmap_hole = 0; /* the previous hole found in the bitmap */
      char string[MAXLEN];
 
      int prev_block_number = 0; /* needed to support netascii convertion */
